# Лабораторная работа: Контейнеризация распределённого приложения

## 1. Введение

### 1.1. Цель работы
Цель данной лабораторной работы — научиться создавать контейнеризованное распределённое приложение с использованием Docker и Docker Compose. В рамках работы вы:
- Запакуете два готовых сервиса (bot.jar и scrapper.jar) в Docker-образы.
- Настроите базу данных PostgreSQL для двух сервисов (отдельные БД для бота и для scrapper).
- Организуете сеть и общий docker‑compose для взаимодействия контейнеров.
- Вынесёте все чувствительные данные (токены, пароли, адреса) в файл переменных окружения (.env).
- (Дополнительно) Реализовать multistage сборку в Dockerfile, healthcheck для контейнеров и/или централизованное логирование

### 1.2. Описание приложения
**Общая идея:**  
Приложение состоит из двух взаимосвязанных микросервисов:
- **Telegram Bot** – сервис, реализующий Telegram‑бота, который принимает команды пользователя, сохраняет ссылки и отправляет уведомления.
- **Scrapper** – сервис для мониторинга обновлений на отслеживаемых ресурсах. Он получает ссылки от бота, сохраняет их в своей базе данных, периодически проверяет изменения и отправляет уведомления обратно в бот.

**Схема взаимодействия:**

```
Пользователь
│
▼
[ Telegram Bot (порт 8080) ]  ←→  [ Scrapper (порт 8081) ]
│                              │
▼                              ▼
PostgreSQL (БД bot)        PostgreSQL (БД scrapperdb)
```

Сервисы общаются между собой по HTTP (например, scrapper отправляет обновления через endpoint `/bot/notify` бота). Взаимодействие происходит по именам контейнеров в общей сети Docker.

---

## 2. Переменные окружения (.env)

Файл `.env` должен содержать все секретные и конфигурационные данные. Пример таблицы с описанием переменных:

| Переменная                     | Описание                                              | Пример значения                              |
|--------------------------------|-------------------------------------------------------|----------------------------------------------|
| `POSTGRES_DB`                  | Имя БД по умолчанию (используется для первоначальной инициализации) | `postgres`                                   |
| `POSTGRES_USER`                | Имя пользователя для PostgreSQL                     | `user`                                       |
| `POSTGRES_PASSWORD`            | Пароль для PostgreSQL                                 | `qwerty`                                     |
| `TELEGRAM_BOT_TOKEN`           | Токен бота, полученный от @BotFather                   | `тут ваш токен`                              |
| `BOT_NOTIFICATION_URL`         | URL для уведомлений в бот (используется scrapper для связи с ботом) | `http://bot:8080/bot/notify`                 |
| `BOT_DATASOURCE_URL`           | JDBC URL для подключения бота к своей базе данных      | `jdbc:postgresql://postgres:5432/bot`        |
| `BOT_DATASOURCE_USERNAME`      | Имя пользователя для БД бота                          | `admin`                                      |
| `BOT_DATASOURCE_PASSWORD`      | Пароль для БД бота                                     | `1357`                                       |
| `BOT_SERVER_PORT`              | Порт, на котором работает бот                         | `8080`                                       |
| `SCRAPPER_DATASOURCE_URL`      | JDBC URL для подключения scrapper к своей базе данных   | `jdbc:postgresql://postgres:5432/scrapperdb` |
| `SCRAPPER_DATASOURCE_USERNAME` | Имя пользователя для БД scrapper                     | `admin`                                      |
| `SCRAPPER_DATASOURCE_PASSWORD` | Пароль для БД scrapper                                | `qwerty`                                     |
| `SCRAPPER_SERVER_PORT`         | Порт, на котором работает scrapper                    | `8081`                                       |
| `SCRAPPER_LINK_URL`            | URL, по которому бот взаимодействует со scrapper       | `http://scrapper:8081/scrapper/link`         |
| `GITHUB_TOKEN`                 | (Опционально) API токен для GitHub                     | `your_github_token_if_needed`                |
| `STACKOVERFLOW_KEY`            | (Опционально) API ключ для StackOverflow               | `your_stackoverflow_key_if_needed`           |
| `STACKOVERFLOW_ACCESS_TOKEN`   | (Опционально) Access Token для StackOverflow           | `your_stackoverflow_access_token_if_needed`  |
| `REDIS_HOST`                   | Имя хоста для Redis (внутри Docker-сети)               | `redis`                                      |
| `REDIS_PORT`                   | Порт для Redis                                        | `6379`                                       |

**Как создать Telegram Bot:**  
1. Найдите [@BotFather](https://t.me/botfather) в Telegram.  
2. Отправьте команду `/newbot` и следуйте инструкциям для создания нового бота.  
3. Полученный токен вставьте в переменную `TELEGRAM_BOT_TOKEN`.

---

## 3. Dockerfile

Студенты должны написать собственные Dockerfile для каждого сервиса. Рассмотрим основные этапы:

| Этап            | Описание                                                         | Пример команд или директив             |
|-----------------|------------------------------------------------------------------|----------------------------------------|
| **Базовый образ**       | Используем официальный образ openjdk для запуска JAR          | `FROM openjdk:23-jdk-slim`              |
| **Рабочая директория**  | Задаём директорию внутри контейнера                           | `WORKDIR /app`                         |
| **Копирование JAR**     | Копируем готовый jar-файл в контейнер                         | `COPY target/bot.jar app.jar` (или scrapper.jar) |
| **Проброс портов**      | Открываем нужный порт для доступа извне                        | `EXPOSE 8080` (или `8081` для scrapper)  |
| **ENTRYPOINT**          | Указываем команду запуска приложения (используем java -jar)    | `ENTRYPOINT ["java", "-jar", "app.jar"]` |

**Дополнительно (Бонус):**  
Можно реализовать multistage сборку, если исходный код доступен, для сборки JAR в первом этапе и создания минимального финального образа во втором.

---

## 4. Docker Compose

Docker Compose позволяет объединить все компоненты в единую систему, описав их в одном YAML-файле.

### Основные элементы, которые студенты должны реализовать:

#### A. Сервисы
Каждый сервис описывается с помощью следующих ключевых параметров:

| Параметр          | Назначение                                                               | Пример значения               |
|--------------------|-------------------------------------------------------------------------|-------------------------------|
| `image`            | Используемый Docker-образ (если образ собирается заранее)              | `postgres:16`                 |
| `build.context`    | Путь к папке, содержащей Dockerfile для сборки образа                    | `./bot` или `./scrapper`       |
| `ports`            | Проброс портов между хостом и контейнером                                | `"8080:8080"`, `"8081:8081"`    |
| `env_file`         | Файл, содержащий переменные окружения                                   | `.env`                        |
| `environment`      | Дополнительные переменные, специфичные для сервиса                        | `SPRING_DATASOURCE_URL: ${BOT_DATASOURCE_URL}` и т.д. |
| `depends_on`       | Определяет, от каких сервисов зависит запуск этого контейнера             | `depends_on: [postgres]`       |
| `restart`          | Политика перезапуска контейнера (например, `always`)                     | `restart: always`             |
| `volumes`          | Монтирование томов или директорий для сохранения данных или инициализации    | `postgres_data:/var/lib/postgresql/data` и `./postgres-init:/docker-entrypoint-initdb.d` |

#### B. Сети
Все сервисы должны находиться в общей сети, чтобы они могли обращаться друг к другу по именам. Обычно используется сеть типа `bridge`.

| Параметр  | Описание                                            | Пример значения  |
|-----------|-----------------------------------------------------|------------------|
| `networks`| Определяет, к какой сети принадлежит сервис         | `networks: [app-network]` |

#### C. Томы (Volumes)
Тома обеспечивают постоянное хранение данных вне контейнера и позволяют инициализировать БД при старте.

| Параметр           | Назначение                                                                 | Пример использования                                          |
|--------------------|----------------------------------------------------------------------------|--------------------------------------------------------------|
| `postgres_data`    | Том для сохранения данных PostgreSQL                                      | `volumes: - postgres_data:/var/lib/postgresql/data`          |
| `./postgres-init`  | Локальная папка с инициализационными скриптами для создания дополнительных баз данных | `- ./postgres-init:/docker-entrypoint-initdb.d`              |

#### D. Пример описания сервиса в docker-compose.yml (пояснение)
Студентам не нужно использовать готовое решение, но нужно пояснить основные моменты:
- **Postgres:**  
  – Используйте образ `postgres:16` с переменными из `.env`.  
  – Проброс порта `"5432:5432"` для доступа с хоста.  
  – Смонтируйте внешний том, чтобы данные сохранялись, и папку с init‑скриптами для создания баз (например, `bot` и `scrapperdb`).
- **Redis:**  
  – Используйте образ `redis:latest`, пробросьте порты (например, `"6380:6379"`) и используйте переменные из `.env`.
- **Bot и Scrapper:**  
  – Опишите процесс сборки образа с помощью `build.context` и Dockerfile (для каждого сервиса своя папка).  
  – Укажите переменные среды (`environment`) и проброс портов (например, `"${BOT_SERVER_PORT}:${BOT_SERVER_PORT}"`).  
  – Определите зависимости (`depends_on`) от базы данных, чтобы приложения запускались после её инициализации.  
  – При необходимости смонтируйте файл `.env` внутрь контейнера с параметром read-only.

---

## 5. Инструкция по развертыванию

**Шаг 1. Создание файла .env**  
- Создайте файл `.env` в корне проекта и заполните его в соответствии с представленной выше таблицей.
- Получите необходимый Telegram Bot Token через @BotFather и вставьте его в `TELEGRAM_BOT_TOKEN`.

**Шаг 2. Подготовка Dockerfile для каждого сервиса**  
- Напишите Dockerfile для bot-сервиса и scrapper-сервиса, руководствуясь инструкциями из раздела 3.
- Проверьте, что готовые jar‑файлы находятся в каталоге `target` с именами, соответствующими указанным в Dockerfile.

**Шаг 3. Подготовка инициализационных скриптов для PostgreSQL**  
- В каталоге (например, `./postgres-init`) создайте скрипт (например, `init_databases.sh`), который создаст базы `bot` и `scrapperdb` при первом запуске контейнера. Или используйте уже готовый скрипт `postgres-init/01-create-databases.sql`
- Пример: скрипт должен проверить, существуют ли базы, и если нет, выполнить их создание.

**Шаг 4. Создание docker-compose.yml**  
- Сформируйте файл `docker-compose.yml`, который включает все описанные сервисы, тома, сети и переменные.
- Проверьте, чтобы для каждого сервиса были корректно указаны:
  - Переменные окружения (через `env_file` и `environment`).
  - Проброс портов.
  - Смонтированные тома (например, для данных PostgreSQL и инициализационных скриптов).
  - Зависимости (`depends_on`).
  - Подключение к общей сети (например, `app-network`).

**Шаг 5. Сборка и запуск контейнеров**  
- Выполните команду:
  ```bash
  docker-compose up --build -d
  ```
- Убедитесь, что все контейнеры запущены:
  ```bash
  docker-compose ps
  ```
- Проверьте логи каждого сервиса:
  ```bash
  docker-compose logs -f
  ```

**Шаг 6. Тестирование работы приложения**
- Будет доступна swagger документация: `http://127.0.0.1:8080/swagger-ui/index.html#/` (с ней можно ознакомиться и узнать, какой эндпоинт как работает
- Откройте Telegram и отправьте комманды боту (например, `/start`, `/track`, `/list` и `/search`) - подробнее в п.6 данного ТЗ.
- Проверьте, что бот сохраняет ссылки и отображает их по соответствующим командам.
- Просмотрите логи scrapper‑сервиса, чтобы убедиться, что он периодически проверяет обновления и отправляет уведомления.
- Подключитесь к базе данных через psql и проверьте, что созданы базы `bot` и `scrapperdb`, а также что выполнены миграции (проверьте таблицы с помощью команды `\dt`).

---

## 6. Проверка работоспособности (Тест-кейсы)

### Тест-кейсы для взаимодействия:
| Действие                     | Ожидаемый результат                              |
|------------------------------|--------------------------------------------------|
| Отправка команды `/start`    | Приветственное сообщение от бота                 |
| Отправка команды `/track <URL>` | Ссылка сохраняется в базе данных для бота       |
| Отправка команды `/list`     | Вывод списка всех отслеживаемых ссылок           |
| Отправка команды `/search <тег>` | Отображение ссылок, содержащих указанный тег  |
| Проверка логов scrapper      | Регулярная проверка ссылок в БД scrapperdb         |
| При изменении данных в отслеживаемом ресурсе | Бот получает уведомление через REST-эндпоинт  |

### Команды для диагностики:
```bash
# Просмотр логов сервиса бота
docker-compose logs -f bot

# Просмотр логов scrapper-сервиса
docker-compose logs -f scrapper

# Проверка состояния PostgreSQL (например, для базы bot)
docker exec -it postgres_db psql -U admin -d bot -c "\dt"

# Проверка сети Docker (имя сети должно совпадать с указанным в docker-compose)
docker network inspect app-network
```

---

## 7. Типичные проблемы и решения

| Проблема                              | Причина                              | Решение                                                 |
|---------------------------------------|--------------------------------------|---------------------------------------------------------|
| "Database does not exist"             | Инициализация БД не выполнена        | Проверить скрипты в `./postgres-init` и переменные в `.env`  |
| "Port already in use"                 | Конфликт портов на хосте             | Освободить порт или изменить портовой маппинг в docker-compose  |
| "Connection refused" между сервисами  | Неправильная настройка сети          | Проверить переменные окружения (например, использовать `postgres` вместо `localhost`) и секцию `networks`   |
| Ошибки миграций (например, таблица уже существует) | Повторное выполнение миграций или неверная последовательность  | Очистить данные или таблицу `databasechangelog`, проверить порядок выполнения init-скриптов  |
| Приложение не стартует из-за неверного JAR пути | Неправильное имя JAR или его отсутствие | Убедиться, что jar-файл собран, и имя файла соответствует настройкам в Dockerfile |

---

## 8.Чек-лист и распределение баллов
Ниже приведён пример таблицы с разбивкой пунктов задания и соответствующими баллами.

| **Этап**                                      | **Описание задания**                                                                                                                                                                                                                                                | **Максимум баллов** | **Критерии/Комментарий**                                                                                                                                                                                                                                                                                                                                                                                                      |
|-----------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **1. Определение компонентов и архитектуры**  | Студент должен описать общую идею приложения: назначение сервисов (Telegram Bot и Scrapper), баз данных (две базы для бота и scrapper) и взаимодействие между ними через сеть.                                                                                      | 10                  | Описание должно включать схему взаимодействия, пояснение назначения каждого сервиса, указание используемых технологий (Java/Spring Boot, PostgreSQL, Redis) и архитектурные решения (общая сеть, коммуникация через HTTP).                                                                                                                                                                                             |
| **2. Файл переменных окружения (.env)**       | В файле .env должны быть вынесены все секретные данные и настройки подключения (например, токены, JDBC URL, учетные данные для БД, порты, ключи API).                                                                                                                  | 15                  | Переменные: POSTGRES_USER, POSTGRES_PASSWORD, TELEGRAM_BOT_TOKEN, BOT_DATASOURCE_URL, SCRAPPER_DATASOURCE_URL, BOT_SERVER_PORT, SCRAPPER_SERVER_PORT, и т.д. Документированное описание в README.md, что это за параметры и где они получаются.                                                                                                                                                                          |
| **3. Dockerfile для сервисов**                | Студент должен написать Dockerfile для каждого сервиса (bot и scrapper). Обязательные элементы: базовый образ (openjdk:23-jdk-slim), WORKDIR, COPY jar-файла, EXPOSE порта, ENTRYPOINT. (Опционально – multistage сборка)                                                | 20                  | Dockerfile должен быть корректным и собирать минимальный образ с вашим jar-файлом.<br>Если multistage сборка реализована – бонусные баллы.                                                                                                                                                                                                                                                                                |
| **4. Инициализация базы данных (PostgreSQL)**   | Необходимо создать скрипты (например, init_databases.sh в папке, смонтированной в /docker-entrypoint-initdb.d) для создания двух баз данных: bot и scrapperdb.                                                                                                         | 15                  | Скрипт должен создавать базы, если они не существуют, и иметь права на выполнение.<br>Описание этого процесса в README.md.                                                                                                                                                                                                                                                                                              |
| **5. Docker Compose конфигурация**            | Студент должен написать docker-compose.yml, который включает все сервисы: PostgreSQL, Redis (опционально), bot и scrapper. Настроить env_file, environment, depends_on, тома, сети и проброс портов.                                                               | 25                  | docker-compose.yml должен быть структурирован – каждая секция (services, volumes, networks) должна быть описана.<br>Переменные должны передаваться из .env (например, SPRING_DATASOURCE_URL, BOT_SERVER_PORT и т.д.).<br>Важно указать depends_on (например, чтобы bot и scrapper запускались после Postgres) и указать общую сеть (например, app-network).                                                          |
| **6. Настройка сети и томов**                 | Описание настройки сети: использование общей bridge-сети для связи контейнеров. Организация томов для постоянного хранения данных (например, postgres_data) и инициализации БД (подключение каталога с init‑скриптами).                                             | 10                  | В docker-compose.yml должны быть определены тома и сети.<br>Студент должен объяснить, зачем используются volumes (для сохранения данных) и сети (для связи контейнеров).                                                                                                                                                                                                                                                  |
| **7. Запуск приложения**                      | Приложение должно корректно собираться и запускаться командой `docker-compose up --build -d` без ошибок.                                                                                                                  | 10                  | Все контейнеры запускаются, приложение доступно по указанным портам (например, бот – 8080, scrapper – 8081).                                                                                                                                                                                                                                                                                                               |
| **8. Тестирование и демонстрация функциональности** | Провести тестирование работы приложения: отправка команд через Telegram, проверка
